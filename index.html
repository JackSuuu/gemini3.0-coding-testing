<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Cyber FPS: 2077 Edition (Fixed Hitbox)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            background-color: #000;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 60%, rgba(255, 0, 50, 0.5) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
            z-index: 4;
            box-shadow: inset 0 0 50px rgba(255,0,0,0.2);
        }
        
        #scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 3;
            opacity: 0.15;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #crosshair-dot {
            width: 4px;
            height: 4px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 8px #0ff;
        }

        #crosshair-circle {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            box-sizing: border-box;
            transition: all 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        #crosshair-lines {
            position: absolute;
            width: 40px;
            height: 40px;
        }
        
        #crosshair-lines::before, #crosshair-lines::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.5);
        }
        #crosshair-lines::before { top: 50%; left: 0; width: 100%; height: 1px; transform: translateY(-50%); }
        #crosshair-lines::after { left: 50%; top: 0; height: 100%; width: 1px; transform: translateX(-50%); }

        .hit-marker {
            border-color: #ff0055 !important;
            transform: scale(0.5) !important;
            background-color: rgba(255, 0, 85, 0.3);
            box-shadow: 0 0 15px #ff0055;
        }

        .hud-panel {
            display: flex;
            justify-content: space-between;
            padding: 40px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .hud-box {
            background: rgba(0, 10, 20, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.5);
            padding: 15px 25px;
            backdrop-filter: blur(4px);
            transform: skewX(-15deg);
            border-left: 4px solid #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }

        #health-container { 
            color: #ff3366; 
            border-left-color: #ff3366;
            text-shadow: 0 0 10px #ff3366; 
        }
        
        #score-container { 
            color: #fcee0a; 
            border-left-color: #fcee0a;
            text-shadow: 0 0 10px #fcee0a; 
        }

        .bar-bg {
            width: 200px;
            height: 10px;
            background: rgba(50, 0, 20, 0.5);
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
        
        #hp-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #ff3366);
            box-shadow: 0 0 15px #ff0055;
            transition: width 0.2s ease-out;
        }

        #blocker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(8px);
        }

        #instructions {
            text-align: center;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 60px;
            background: rgba(0, 20, 30, 0.9);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.1);
            max-width: 600px;
            position: relative;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        h1 {
            font-size: 64px;
            margin: 0 0 20px 0;
            color: #fcee0a;
            text-shadow: 4px 4px 0px #ff0055;
            font-style: italic;
        }

        p { font-size: 18px; line-height: 1.8; color: #eee; }

        .key {
            display: inline-block;
            background: transparent;
            border: 1px solid #fcee0a;
            color: #fcee0a;
            padding: 2px 8px;
            border-radius: 2px;
            font-size: 14px;
            margin: 0 2px;
            box-shadow: 0 0 5px rgba(252, 238, 10, 0.4);
        }

        #game-over {
            display: none;
            color: #ff0055;
            font-size: 80px;
            font-weight: 900;
            text-shadow: 0 0 30px #ff0055;
            margin-bottom: 20px;
            animation: glitch 1s infinite alternate;
        }

        @keyframes glitch {
            0% { transform: skewX(0deg); text-shadow: 2px 2px #0ff; }
            20% { transform: skewX(-10deg); text-shadow: -2px -2px #fcee0a; }
            40% { transform: skewX(10deg); text-shadow: 2px -2px #ff0055; }
            100% { transform: skewX(0deg); text-shadow: 0 0 20px #ff0055; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="scanlines"></div>
    <div id="damage-overlay"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <div id="health-container" class="hud-box">
                <div>SYSTEM STATUS</div>
                <div class="bar-bg"><div id="hp-bar"></div></div>
            </div>
            <div id="score-container" class="hud-box">
                BOUNTY: <span id="score-text">0</span>
            </div>
        </div>
        <div id="crosshair">
            <div id="crosshair-lines"></div>
            <div id="crosshair-circle"></div>
            <div id="crosshair-dot"></div>
        </div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <div id="game-over">CRITICAL FAILURE</div>
            <h1>NEON REVOLT</h1>
            <p>
                点击屏幕接入神经连接<br><br>
                移动: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> &nbsp;
                跳跃: <span class="key">SPACE</span><br>
                射击: <span class="key">LMB</span> &nbsp; 
                视角: <span class="key">MOUSE</span><br>
                系统重启: <span class="key">R</span>
            </p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 全局配置 ---
        const COLORS = {
            neonBlue: 0x00f0ff,
            neonPink: 0xff0055,
            neonYellow: 0xfcee0a,
            darkBg: 0x0f0f1a,
            grid: 0x220044
        };

        let camera, scene, renderer, controls;
        let raycaster;
        
        let isGameActive = false;
        let lastTime = performance.now();
        let score = 0;
        const maxHealth = 100;
        let playerHealth = maxHealth;
        
        const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const playerSpeed = 40.0; 
        const jumpForce = 18.0;   
        const gravity = 60.0;     
        let canJump = false;

        const obstacles = []; 
        const enemies = [];   
        const particles = []; 
        
        let gunGroup;
        let muzzleFlashLight, muzzleFlashMesh;
        let gunSwayTime = 0;
        let gunRecoil = 0;

        let audioCtx;

        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const scoreEl = document.getElementById('score-text');
        const hpBar = document.getElementById('hp-bar');
        const gameOverText = document.getElementById('game-over');
        const damageOverlay = document.getElementById('damage-overlay');
        const crosshairCircle = document.getElementById('crosshair-circle');

        function createGridTexture() {
            const size = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#0a0a14'; 
            ctx.fillRect(0, 0, size, size);
            
            ctx.strokeStyle = '#d040ff'; 
            ctx.lineWidth = 3;           
            ctx.shadowBlur = 12;         
            ctx.shadowColor = '#d040ff';
            
            ctx.beginPath();
            ctx.strokeRect(0, 0, size, size);
            ctx.moveTo(size/2, 0); ctx.lineTo(size/2, size);
            ctx.moveTo(0, size/2); ctx.lineTo(size, size/2);
            
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = '#00ffff'; 
            ctx.shadowColor = '#00ffff';
            ctx.strokeRect(size/4, size/4, size/2, size/2);
            
            ctx.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.anisotropy = 16; 
            
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#111111'; 
            ctx.fillRect(0,0,128,256);
            
            for(let i=0; i<25; i++) { 
                if(Math.random() > 0.4) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#fcee0a' : '#00f0ff';
                    ctx.globalAlpha = 0.8;
                    const x = Math.floor(Math.random()*4) * 32 + 5;
                    const y = Math.floor(Math.random()*8) * 32 + 5;
                    const w = 20;
                    const h = 10;
                    ctx.fillRect(x,y,w,h);
                    ctx.globalAlpha = 1.0;
                }
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.darkBg);
            scene.fog = new THREE.FogExp2(COLORS.darkBg, 0.01); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.7;
            scene.add(camera); 

            const ambientLight = new THREE.AmbientLight(0xffffff, 2.5); 
            scene.add(ambientLight);

            const cityLight = new THREE.HemisphereLight(0x4444ff, 0x111111, 1.2);
            scene.add(cityLight);

            const dirLight = new THREE.DirectionalLight(0xd0aaff, 2.0);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.bias = -0.0005; 
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; 
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);

            blocker.addEventListener('click', () => {
                if (playerHealth > 0) controls.lock();
            });

            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                isGameActive = true;
                initAudio();
            });

            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = '';
                if (playerHealth > 0) gameOverText.style.display = 'none';
                isGameActive = false;
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            raycaster = new THREE.Raycaster();

            createEnvironment();
            createSciFiGun();
            
            spawnEnemies(3);
        }

        function createEnvironment() {
            const gridTex = createGridTexture();
            gridTex.repeat.set(40, 40); 

            const floorGeo = new THREE.PlaneGeometry(300, 300);
            const floorMat = new THREE.MeshStandardMaterial({ 
                map: gridTex,
                color: 0xaaaaaa, 
                roughness: 0.2, 
                metalness: 0.5,
                emissive: 0x111133, 
                emissiveIntensity: 0.3
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                roughness: 0.2,
                metalness: 0.7
            });
            const neonCyanMat = new THREE.MeshBasicMaterial({ color: 0x44ffff }); 
            const neonPinkMat = new THREE.MeshBasicMaterial({ color: 0xff4488 }); 

            function createCyberBox(w, h, d, x, y, z, color = 'cyan', isStatic = false) {
                const group = new THREE.Group();
                group.position.set(x, y, z);

                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, wallMat);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);

                const edges = new THREE.EdgesGeometry(geo);
                const lineMat = (color === 'pink') ? neonPinkMat : neonCyanMat;
                const line = new THREE.LineSegments(edges, lineMat);
                lineMat.toneMapped = false; 
                group.add(line);

                if (!isStatic) {
                    const glowLight = new THREE.PointLight((color === 'pink') ? 0xff0055 : 0x00f0ff, 0.5, 10);
                    group.add(glowLight);
                }

                scene.add(group);
                group.updateMatrixWorld(true);

                const box = new THREE.Box3().setFromObject(mesh);
                if (isStatic) {
                   obstacles.push({ mesh: mesh, box: box });
                } else {
                   obstacles.push({ mesh: mesh, box: box });
                }
            }

            createCyberBox(200, 15, 4, 0, 7.5, -100, 'cyan', true);
            createCyberBox(200, 15, 4, 0, 7.5, 100, 'cyan', true);
            createCyberBox(4, 15, 200, -100, 7.5, 0, 'cyan', true);
            createCyberBox(4, 15, 200, 100, 7.5, 0, 'cyan', true);

            for (let i = 0; i < 25; i++) {
                let x = (Math.random() - 0.5) * 160;
                let z = (Math.random() - 0.5) * 160;
                if (Math.abs(x) < 15 && Math.abs(z) < 15) continue;

                const w = 4 + Math.random() * 6;
                const h = 2 + Math.random() * 3;
                const d = 4 + Math.random() * 6;
                
                createCyberBox(w, h, d, x, h/2, z, Math.random() > 0.5 ? 'pink' : 'cyan', true);
            }

            const buildingTex = createBuildingTexture();
            const buildingMat = new THREE.MeshBasicMaterial({ map: buildingTex, color: 0x999999 }); 
            
            for(let i=0; i<60; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 120 + Math.random() * 100;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const h = 50 + Math.random() * 100;
                const w = 10 + Math.random() * 20;

                const geo = new THREE.BoxGeometry(w, h, w);
                const mesh = new THREE.Mesh(geo, buildingMat);
                mesh.position.set(x, h/2 - 20, z);
                scene.add(mesh);
            }
        }

        function createSciFiGun() {
            gunGroup = new THREE.Group();

            const gunMetal = new THREE.MeshStandardMaterial({ 
                color: 0x888888, 
                roughness: 0.2, 
                metalness: 0.8 
            });
            const gunBlack = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.5, 
                metalness: 0.3 
            });
            const glowBlue = new THREE.MeshBasicMaterial({ color: 0x66ffff });
            const glowPink = new THREE.MeshBasicMaterial({ color: 0xff66aa });

            const bodyGeo = new THREE.BoxGeometry(0.1, 0.15, 0.4);
            const body = new THREE.Mesh(bodyGeo, gunMetal);
            body.position.z = 0.1;
            gunGroup.add(body);

            const stockGeo = new THREE.BoxGeometry(0.08, 0.12, 0.2);
            const stock = new THREE.Mesh(stockGeo, gunBlack);
            stock.position.set(0, -0.02, 0.4);
            gunGroup.add(stock);

            const sideGlowGeo = new THREE.BoxGeometry(0.11, 0.02, 0.3);
            const sideGlow = new THREE.Mesh(sideGlowGeo, glowBlue);
            sideGlow.position.set(0, 0.05, 0.1);
            gunGroup.add(sideGlow);

            const barrelCoverGeo = new THREE.BoxGeometry(0.08, 0.08, 0.4);
            const barrelCover = new THREE.Mesh(barrelCoverGeo, gunBlack);
            barrelCover.position.set(0, 0.05, -0.25);
            gunGroup.add(barrelCover);

            const barrelGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.6);
            const barrel = new THREE.Mesh(barrelGeo, gunMetal);
            barrel.rotation.x = Math.PI/2;
            barrel.position.set(0, 0.05, -0.4);
            gunGroup.add(barrel);

            const scopeGeo = new THREE.BoxGeometry(0.06, 0.04, 0.15);
            const scope = new THREE.Mesh(scopeGeo, gunBlack);
            scope.position.set(0, 0.18, 0.1);
            gunGroup.add(scope);
            
            const lensGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.01);
            const lens = new THREE.Mesh(lensGeo, glowPink);
            lens.rotation.x = Math.PI/2;
            lens.position.set(0, 0.18, 0.02);
            gunGroup.add(lens);

            const flashGeo = new THREE.PlaneGeometry(0.8, 0.8);
            const flashMat = new THREE.MeshBasicMaterial({
                color: COLORS.neonBlue,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            muzzleFlashMesh = new THREE.Mesh(flashGeo, flashMat);
            muzzleFlashMesh.position.set(0, 0.05, -0.8);
            gunGroup.add(muzzleFlashMesh);

            muzzleFlashLight = new THREE.PointLight(COLORS.neonBlue, 0, 10);
            muzzleFlashLight.position.set(0, 0.05, -0.7);
            gunGroup.add(muzzleFlashLight);

            const gunLight = new THREE.PointLight(0xffffff, 1.0, 3); 
            gunLight.position.set(0, 0.5, 0); 
            gunGroup.add(gunLight);

            camera.add(gunGroup);
            gunGroup.position.set(0.3, -0.3, -0.4);
        }

        class Enemy {
            constructor() {
                const geo = new THREE.IcosahedronGeometry(1.2, 0);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0x550000, 
                    emissive: 0xff0000, 
                    emissiveIntensity: 0.8, 
                    roughness: 0.3,
                    metalness: 0.8,
                    flatShading: true,
                    side: THREE.DoubleSide // [FIX] 允许双面渲染，防止穿模后不可见/不可检测
                });
                
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                
                const ringGeo = new THREE.TorusGeometry(1.8, 0.05, 8, 30);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xff3333, wireframe: true }); 
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.mesh.add(this.ring);

                let validPos = false;
                let attempts = 0;
                let spawnPos = new THREE.Vector3();

                while (!validPos && attempts < 50) {
                    const x = (Math.random() - 0.5) * 180;
                    const z = (Math.random() - 0.5) * 180;
                    spawnPos.set(x, 2, z);

                    if (spawnPos.distanceTo(camera.position) < 30) {
                        attempts++;
                        continue;
                    }

                    let insideWall = false;
                    const enemyBox = new THREE.Box3().setFromCenterAndSize(spawnPos, new THREE.Vector3(3,3,3));
                    
                    for (const obs of obstacles) {
                        if (enemyBox.intersectsBox(obs.box)) {
                            insideWall = true;
                            break;
                        }
                    }

                    if (!insideWall) {
                        validPos = true;
                    }
                    attempts++;
                }

                if (!validPos) spawnPos.y = 10;

                this.mesh.position.copy(spawnPos);
                scene.add(this.mesh);
                
                createParticleExplosion(spawnPos, COLORS.neonPink, 10);

                this.health = 100;
                this.speed = 10 + Math.random() * 8; 
                this.box = new THREE.Box3();
                
                this.floatOffset = Math.random() * 100;
                this.rotateSpeed = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5);
            }

            update(delta, playerPos, time) {
                if (this.health <= 0) return;

                this.mesh.rotation.x += this.rotateSpeed.x * delta;
                this.mesh.rotation.y += this.rotateSpeed.y * delta;
                this.ring.rotation.x -= delta * 2;
                this.ring.rotation.y -= delta;

                this.mesh.position.y = 2.5 + Math.sin(time * 3 + this.floatOffset) * 0.5;

                const dist = this.mesh.position.distanceTo(playerPos);
                
                if (dist < 60) {
                    const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();
                    dir.y = 0;
                    
                    // 警告色
                    this.mesh.material.emissiveIntensity = 1.5 + Math.sin(time * 15) * 0.8;
                    
                    // [FIX] 距离大于 3.5 才移动，防止贴脸穿模
                    if (dist > 3.5) {
                        this.mesh.position.add(dir.multiplyScalar(this.speed * delta));
                    }
                } else {
                    this.mesh.material.emissiveIntensity = 0.8;
                }

                this.box.setFromObject(this.mesh);

                if (dist < 2.5 && isGameActive) {
                    takeDamage(15 * delta);
                }
            }

            hit() {
                this.health -= 40;
                const originalColor = this.mesh.material.emissive.getHex();
                this.mesh.material.emissive.setHex(0xffffff);
                this.mesh.material.emissiveIntensity = 8.0; 
                
                playHitSound();

                setTimeout(() => {
                    if (this.health > 0) {
                        this.mesh.material.emissive.setHex(originalColor);
                        this.mesh.material.emissiveIntensity = 0.8;
                    }
                }, 80);

                if (this.health <= 0) this.explode();
            }

            explode() {
                createParticleExplosion(this.mesh.position, COLORS.neonPink, 25);
                createParticleExplosion(this.mesh.position, COLORS.neonYellow, 10);
                scene.remove(this.mesh);
                addScore(150);
            }
        }

        function spawnEnemies(count) {
            for(let i=0; i<count; i++) {
                enemies.push(new Enemy());
            }
        }

        function createParticleExplosion(pos, color, count = 15) {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            
            for(let i=0; i<count; i++) {
                positions.push(pos.x, pos.y, pos.z);
                
                const speed = 5 + Math.random() * 15;
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;

                velocities.push(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 0.6,
                color: color,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                toneMapped: false 
            });
            
            const system = new THREE.Points(geo, mat);
            scene.add(system);
            particles.push({ mesh: system, velocities: velocities, life: 0.8 });
        }

        function shoot() {
            if (playerHealth <= 0) return;
            
            gunRecoil = 0.2; 
            playShootSound();

            muzzleFlashMesh.material.opacity = 1;
            muzzleFlashMesh.rotation.z = Math.random() * Math.PI * 2;
            muzzleFlashLight.intensity = 8;
            
            // [FIX] 优先进行“贴脸必中”检测
            // 如果有敌人在极近距离（<5米），直接视为命中最近的那个
            let closestEnemy = null;
            let minDistance = 5.0;

            for(const enemy of enemies) {
                if (enemy.health > 0) {
                    const dist = enemy.mesh.position.distanceTo(camera.position);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestEnemy = enemy;
                    }
                }
            }

            if (closestEnemy) {
                // 贴脸命中
                const hitPoint = closestEnemy.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)); // 假定击中中心上方
                createParticleExplosion(hitPoint, COLORS.neonBlue, 10);
                crosshairCircle.classList.add('hit-marker');
                setTimeout(() => crosshairCircle.classList.remove('hit-marker'), 100);
                closestEnemy.hit();
                return; // 已经命中了，不再进行射线检测
            }
            
            // 常规射线检测
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const hits = [];
            for(const enemy of enemies) {
                if (enemy.health > 0) hits.push(enemy.mesh);
            }
            
            const intersects = raycaster.intersectObjects(hits, true);

            if (intersects.length > 0) {
                const hitPoint = intersects[0].point;
                createParticleExplosion(hitPoint, COLORS.neonBlue, 8);

                crosshairCircle.classList.add('hit-marker');
                setTimeout(() => crosshairCircle.classList.remove('hit-marker'), 100);

                let obj = intersects[0].object;
                while(obj.parent && obj.parent.type !== 'Scene') {
                    obj = obj.parent;
                }
                
                const enemy = enemies.find(e => e.mesh === obj);
                if (enemy) enemy.hit();
            } else {
                const envIntersects = raycaster.intersectObjects(scene.children);
                if (envIntersects.length > 0 && envIntersects[0].object.geometry.type !== 'PlaneGeometry') { 
                     createParticleExplosion(envIntersects[0].point, 0xffffaa, 5);
                }
            }
        }

        function takeDamage(amount) {
            playerHealth = Math.max(0, playerHealth - amount);
            hpBar.style.width = playerHealth + '%';
            
            damageOverlay.style.opacity = 0.8;
            setTimeout(() => damageOverlay.style.opacity = 0, 250);
            
            if (playerHealth <= 0) endGame();
        }

        function addScore(val) {
            score += val;
            scoreEl.innerText = score;
            
            const aliveCount = enemies.filter(e => e.health > 0).length;
            
            if (aliveCount < 2) {
                const newCount = 3 + Math.floor(score / 500);
                setTimeout(() => spawnEnemies(newCount), 1000);
            }
        }

        function endGame() {
            isGameActive = false;
            controls.unlock();
            instructions.style.display = 'block';
            gameOverText.style.display = 'block';
            blocker.style.display = 'flex';
        }

        function resetGame() {
            playerHealth = maxHealth;
            score = 0;
            hpBar.style.width = '100%';
            scoreEl.innerText = 0;
            gameOverText.style.display = 'none';
            camera.position.set(0, 1.7, 0);
            velocity.set(0,0,0);
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            spawnEnemies(3);
            controls.lock();
        }

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playShootSound() {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            
            const bufferSize = audioCtx.sampleRate * 0.1; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.5, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start();

            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
            
            const oscGain = audioCtx.createGain();
            oscGain.gain.setValueAtTime(0.3, t);
            oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            
            osc.connect(oscGain);
            oscGain.connect(audioCtx.destination);
            osc.start();
            osc.stop(t + 0.2);
        }

        function playHitSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            osc.frequency.setValueAtTime(1500, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.05);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.05);
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': if(canJump) { velocity.y += jumpForce; canJump = false; } break;
                case 'KeyR': if(!isGameActive && playerHealth <= 0) resetGame(); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        }
        function onMouseDown(e) {
            if(isGameActive && e.button === 0) shoot();
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function checkCollisions(newPos) {
            const r = 0.6; 
            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - r, newPos.y - 1.5, newPos.z - r),
                new THREE.Vector3(newPos.x + r, newPos.y + 0.5, newPos.z + r)
            );
            for (const ob of obstacles) {
                if (playerBox.intersectsBox(ob.box)) return true;
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() / 1000;
            const delta = Math.min((performance.now() - lastTime) / 1000, 0.1);
            lastTime = performance.now();

            if (controls.isLocked && playerHealth > 0) {
                velocity.x -= velocity.x * 8.0 * delta; 
                velocity.z -= velocity.z * 8.0 * delta;
                velocity.y -= gravity * delta;

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize();

                if (moveState.forward || moveState.backward) velocity.z -= direction.z * playerSpeed * delta;
                if (moveState.left || moveState.right) velocity.x -= direction.x * playerSpeed * delta;

                controls.moveRight(-velocity.x * delta);
                if (checkCollisions(camera.position)) {
                    controls.moveRight(velocity.x * delta);
                    velocity.x = 0;
                }
                
                controls.moveForward(-velocity.z * delta);
                if (checkCollisions(camera.position)) {
                    controls.moveForward(velocity.z * delta);
                    velocity.z = 0;
                }

                camera.position.y += velocity.y * delta;
                if (camera.position.y < 1.7) {
                    velocity.y = 0;
                    camera.position.y = 1.7;
                    canJump = true;
                }

                gunRecoil = Math.max(0, gunRecoil - delta * 3);
                
                if (velocity.x !== 0 || velocity.z !== 0) {
                    gunSwayTime += delta * 12;
                    gunGroup.position.x = 0.3 + Math.sin(gunSwayTime) * 0.015;
                    gunGroup.position.y = -0.3 + Math.cos(gunSwayTime * 2) * 0.015 + gunRecoil * 0.15;
                    gunGroup.position.z = -0.4 + gunRecoil * 0.3; 
                } else {
                    gunGroup.position.y = -0.3 + Math.sin(time * 2) * 0.005 + gunRecoil * 0.15;
                    gunGroup.position.z = -0.4 + gunRecoil * 0.3;
                    gunGroup.position.x = THREE.MathUtils.lerp(gunGroup.position.x, 0.3, delta * 5);
                }
                
                if (muzzleFlashMesh.material.opacity > 0) {
                    muzzleFlashMesh.material.opacity -= delta * 20;
                    muzzleFlashLight.intensity -= delta * 80;
                }

                const activeEnemies = enemies.filter(e => e.health > 0);
                activeEnemies.forEach(e => e.update(delta, camera.position, time));

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.life -= delta;
                    const pos = p.mesh.geometry.attributes.position.array;
                    for(let j=0; j < pos.length; j+=3) {
                        pos[j]   += p.velocities[j] * delta;
                        pos[j+1] += p.velocities[j+1] * delta;
                        pos[j+2] += p.velocities[j+2] * delta;
                        p.velocities[j+1] -= 5.0 * delta; 
                    }
                    p.mesh.geometry.attributes.position.needsUpdate = true;
                    p.mesh.material.opacity = p.life;
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        particles.splice(i, 1);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();

    </script>
</body>
</html>
