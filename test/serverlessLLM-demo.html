<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ServerlessLLM Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #ffffff; 
            color: #000000; 
            font-family: 'Georgia', 'Times New Roman', Times, serif; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 0; }
        
        /* HUD Elements */
        .hud-panel {
            background: #ffffff;
            border: 2px solid #000000;
            box-shadow: 4px 4px 0px #000000;
            transition: all 0.3s ease;
            border-radius: 0 !important;
        }

        .glow-text {
            font-weight: bold;
            text-decoration: underline;
            text-shadow: none;
        }

        /* Label Styles for 3D elements */
        .label {
            position: absolute;
            background: #ffffff;
            color: #000000;
            padding: 4px 8px;
            border: 1px solid #000000;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            font-family: 'Courier New', Courier, monospace;
        }
        
        .progress-bar {
            transition: width 0.5s ease-in-out;
            background-color: #000000 !important;
        }

        /* Academic Button Styles */
        .academic-btn {
            background-color: #ffffff;
            color: #000000;
            border: 2px solid #000000;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 2px 2px 0px #000000;
        }
        .academic-btn:hover {
            transform: translate(-1px, -1px);
            box-shadow: 4px 4px 0px #000000;
        }
        .academic-btn:active {
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 0px #000000;
        }
        
        .academic-tag {
            background-color: #000000;
            color: #ffffff;
            font-family: 'Courier New', Courier, monospace;
            padding: 2px 6px;
            font-size: 0.75rem;
        }
    </style>
</head>
<body>

    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- Labels Container -->
    <div id="labels-container"></div>

    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between p-6">
        
        <!-- Header -->
        <div class="hud-panel p-6 max-w-md pointer-events-auto">
            <h1 class="text-3xl font-bold text-black mb-2 glow-text" style="font-family: 'Times New Roman', serif;">ServerlessLLM</h1>
            <h2 class="text-sm text-black uppercase tracking-widest mb-4 border-b-2 border-black pb-2">Locality-Enhanced Inference System</h2>
            
            <div id="step-indicator" class="flex items-center space-x-2 mb-4">
                <span class="text-xs font-mono text-black font-bold">PHASE:</span>
                <span id="phase-name" class="academic-tag">INITIALIZATION</span>
            </div>

            <div id="explanation-text" class="text-sm text-black leading-relaxed space-y-3 font-serif italic">
                <p>Initializing 3D Cluster Representation...</p>
            </div>
        </div>

        <!-- Controls -->
        <div class="hud-panel p-4 pointer-events-auto self-end flex gap-4 items-center">
            <div class="flex flex-col items-end mr-4">
                <span class="text-xs text-black font-bold uppercase">SYSTEM STATUS</span>
                <span id="system-status" class="text-sm font-mono text-black border-b border-black">IDLE</span>
            </div>
            <button onclick="prevStep()" class="academic-btn px-4 py-2">
                &larr; Prev
            </button>
            <button onclick="nextStep()" id="next-btn" class="academic-btn px-6 py-2">
                Next Step &rarr;
            </button>
        </div>
    </div>

    <script>
        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); // White background
        scene.fog = new THREE.FogExp2(0xffffff, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Removed colored point lights for academic B&W style

        // --- OBJECT CREATION HELPERS ---
        
        const materials = {
            ssd: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.1 }), // Dark Grey
            dram: new THREE.MeshStandardMaterial({ color: 0xe5e5e5, roughness: 0.2, metalness: 0.1, opacity: 0.9, transparent: true }), // Light Grey
            gpu: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4, metalness: 0.4 }), // Medium Grey
            serverFrame: new THREE.LineBasicMaterial({ color: 0x000000 }), // Black
            modelChunk: new THREE.MeshPhongMaterial({ color: 0x000000 }), // Black
            
            // New materials for the pipeline visualization - Grayscale
            chunkSSD: new THREE.MeshPhongMaterial({ color: 0x444444 }), // Dark Grey
            chunkPinned: new THREE.MeshPhongMaterial({ color: 0xaaaaaa }), // Light Grey
            chunkGPU: new THREE.MeshPhongMaterial({ color: 0x000000 }), // Black

            token: new THREE.MeshBasicMaterial({ color: 0x000000 }) // Black
        };

        const servers = [];
        const packets = []; // For animation elements
        
        function createServer(id, x, z) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            // 1. Base (SSD Layer) - Bottom Tier
            const ssdGeo = new THREE.BoxGeometry(6, 1, 4);
            const ssdMesh = new THREE.Mesh(ssdGeo, materials.ssd);
            ssdMesh.position.y = 0.5;
            ssdMesh.castShadow = true;
            group.add(ssdMesh);

            // Label: SSD
            addTextLabel(x, 0.5, z + 2.5, `Server ${id}: Local SSD`);

            // 2. Middle (DRAM Layer)
            const dramGeo = new THREE.BoxGeometry(6, 0.5, 4);
            const dramMesh = new THREE.Mesh(dramGeo, materials.dram);
            dramMesh.position.y = 2;
            group.add(dramMesh);

            // Connector (PCIe Bus representation)
            const busGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const busMat = new THREE.MeshBasicMaterial({ color: 0x94a3b8 });
            const bus = new THREE.Mesh(busGeo, busMat);
            bus.position.y = 1.25;
            group.add(bus);

            // 3. Top (GPU Layer)
            const gpuGeo = new THREE.BoxGeometry(2, 0.5, 3);
            
            // Create 2 GPUs per server
            const gpu1 = new THREE.Mesh(gpuGeo, materials.gpu);
            gpu1.position.set(-1.5, 3.5, 0);
            group.add(gpu1);
            
            const gpu2 = new THREE.Mesh(gpuGeo, materials.gpu);
            gpu2.position.set(1.5, 3.5, 0);
            group.add(gpu2);

            // Connectors DRAM -> GPU
            const pcie1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), busMat);
            pcie1.position.set(-1.5, 2.75, 0);
            group.add(pcie1);
            
            const pcie2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), busMat);
            pcie2.position.set(1.5, 2.75, 0);
            group.add(pcie2);

            // Frame
            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(6.2, 4.2, 4.2));
            const line = new THREE.LineSegments(edges, materials.serverFrame);
            line.position.y = 2;
            group.add(line);

            scene.add(group);
            
            // Store reference for animation
            servers.push({
                id: id,
                mesh: group,
                components: { ssd: ssdMesh, dram: dramMesh, gpu1: gpu1, gpu2: gpu2 }
            });
        }

        // Initialize Cluster
        createServer(1, -8, 0); // Server 1
        createServer(2, 8, 0);  // Server 2

        // Grid helper
        const gridHelper = new THREE.GridHelper(50, 50, 0x334155, 0x1e293b);
        scene.add(gridHelper);

        // --- VISUALIZATION LOGIC & ANIMATION ---

        let currentStep = 0;
        const totalSteps = 4;

        // Data Chunks (Checkpoint)
        const dataChunks = [];

        function createDataChunk(serverIndex, startY, delay) {
            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const mesh = new THREE.Mesh(geo, materials.chunkSSD); // Start as SSD Blue
            
            // Position relative to specific server
            const serverPos = servers[serverIndex].mesh.position;
            mesh.position.set(serverPos.x - 2 + Math.random()*4, startY, serverPos.z - 1.5 + Math.random()*3);
            
            scene.add(mesh);
            dataChunks.push(mesh);

            return mesh;
        }

        function visualizeLoading(serverIndex) {
            // Animate chunks moving from SSD (y=0.5) to DRAM (y=2) then GPU (y=3.5)
            const server = servers[serverIndex];
            const chunkCount = 40; // Increased density for pipeline effect
            
            for(let i=0; i<chunkCount; i++) {
                const chunk = createDataChunk(serverIndex, 0.5, i * 40);
                
                // Tween 1: SSD to DRAM (Direct I/O optimization)
                const t1 = new TWEEN.Tween(chunk.position)
                    .to({ y: 2 }, 800)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .delay(i * 40)
                    .onStart(() => {
                         // Ensure it starts blue
                         chunk.material = materials.chunkSSD; 
                    });

                // Tween 2: DRAM to GPU (Pinned Memory)
                // Split to left or right GPU randomly
                const targetX = server.mesh.position.x + (Math.random() > 0.5 ? 1.5 : -1.5);
                
                const t2 = new TWEEN.Tween(chunk.position)
                    .to({ x: targetX, y: 3.5 }, 600)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .onStart(() => {
                        // Change to Green (Pinned Memory)
                        chunk.material = materials.chunkPinned;
                    })
                    .onComplete(() => {
                        // Change to Red (GPU Loaded)
                        chunk.material = materials.chunkGPU;
                    });

                t1.chain(t2);
                t1.start();
            }
        }

        function clearDataChunks() {
            dataChunks.forEach(c => scene.remove(c));
            dataChunks.length = 0;
        }

        function visualizeMigration() {
            // Visualize token transfer from Server 1 to Server 2
            const s1 = servers[0].mesh.position;
            const s2 = servers[1].mesh.position;

            // Create a stream of particles (Tokens)
            for (let i = 0; i < 10; i++) {
                const token = new THREE.Mesh(new THREE.SphereGeometry(0.2), materials.token);
                token.position.set(s1.x, 3.5, s1.z); // Start at GPU height
                scene.add(token);
                packets.push(token);

                // Arc motion
                const midX = (s1.x + s2.x) / 2;
                const midY = 8; // Arc height

                new TWEEN.Tween(token.position)
                    .to({ x: s2.x }, 2000)
                    .onUpdate(() => {
                        // Simple parabolic arc approximation for Y
                        const progress = (token.position.x - s1.x) / (s2.x - s1.x);
                        token.position.y = 3.5 + 4 * Math.sin(progress * Math.PI);
                    })
                    .delay(i * 200)
                    .start()
                    .onComplete(() => {
                        scene.remove(token);
                    });
            }
        }

        // --- TEXT LABELS ---
        function addTextLabel(x, y, z, text) {
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = text;
            document.getElementById('labels-container').appendChild(div);
            
            // Update position in render loop
            div.dataset.x = x;
            div.dataset.y = y;
            div.dataset.z = z;
        }

        function updateLabels() {
            const labels = document.querySelectorAll('.label');
            labels.forEach(label => {
                const pos = new THREE.Vector3(
                    parseFloat(label.dataset.x),
                    parseFloat(label.dataset.y),
                    parseFloat(label.dataset.z)
                );
                
                pos.project(camera);
                
                const x = (pos.x * .5 + .5) * window.innerWidth;
                const y = (-(pos.y * .5) + .5) * window.innerHeight;

                if (Math.abs(pos.z) < 1) {
                    label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                    label.style.opacity = '1';
                } else {
                    label.style.opacity = '0';
                }
            });
        }

        // --- NARRATIVE CONTROL ---

        const steps = [
            {
                title: "Architecture Overview",
                status: "CLUSTER READY",
                desc: "ServerlessLLM optimizes standard GPU servers. Each server has a <b>Multi-Tier Storage Hierarchy</b>: <br><br>1. <span class='font-bold'>GPU VRAM</span> (Fastest, Low Capacity)<br>2. <span class='italic'>Host DRAM</span> (Fast, Medium Capacity)<br>3. <span class='underline'>Local NVMe SSD</span> (Slower, Huge Capacity). <br><br>Standard systems waste this local bandwidth. ServerlessLLM exploits it.",
                action: () => {
                    clearDataChunks();
                    new TWEEN.Tween(camera.position).to({x: 0, y: 15, z: 30}, 1000).start();
                }
            },
            {
                title: "Fast Checkpoint Loading",
                status: "MAXIMIZING BANDWIDTH",
                desc: "<b>The Innovation:</b> ServerlessLLM maximizes local bandwidth using a Multi-Tier Loading Pipeline:<br><br>1. <b>Direct I/O (Dark Grey):</b> Chunks are read from SSD directly to memory, bypassing CPU cache.<br>2. <b>Pinned Memory (Light Grey):</b> Data lands in pinned memory for zero-copy transfer.<br>3. <b>Pipelining (Black):</b> While GPU loads one chunk, the next is already being read from SSD.",
                action: () => {
                    clearDataChunks();
                    new TWEEN.Tween(camera.position).to({x: -8, y: 8, z: 15}, 1000).start();
                    setTimeout(() => visualizeLoading(0), 500);
                }
            },
            {
                title: "Locality-Driven Allocation",
                status: "CONTENTION DETECTED",
                desc: "<b>The Problem:</b> Server 1 has 'Model A' loaded (Dark Blocks) and is running inference. A request comes for 'Model B' (not loaded).<br><br>'Model B' is cached on Server 1's SSD, but Server 1's GPU is busy. Server 2 is idle but has no data.<br><br>Should we load B on Server 2 (slow download) or wait for Server 1?",
                action: () => {
                    // Show Server 1 full
                    // Move camera to center
                    new TWEEN.Tween(camera.position).to({x: 0, y: 12, z: 20}, 1000).start();
                }
            },
            {
                title: "Live Migration",
                status: "MIGRATING INFERENCE",
                desc: "<b>The Solution:</b> ServerlessLLM performs <b>Live Migration</b>.<br><br>Instead of moving the massive Model Checkpoint (GBs), it pauses the active inference on Server 1 and moves only the <b>Tokens/KV-Cache</b> (MBs) to Server 2.<br><br>Server 2 resumes 'Model A'. Server 1 is now free to load 'Model B' locally from its fast SSD.",
                action: () => {
                    visualizeMigration();
                    // After migration, show loading on S1
                    setTimeout(() => {
                        // Change color of chunks to imply new model
                        // For the visual effect, we revert to standard material but maybe tinted differently (e.g. lighter/darker)
                        materials.chunkSSD.color.setHex(0x999999); 
                        materials.chunkPinned.color.setHex(0xbbbbbb);
                        materials.chunkGPU.color.setHex(0x555555);
                        
                        visualizeLoading(0);
                        
                        // Reset colors after animation starts (for next loop)
                         setTimeout(() => {
                            materials.chunkSSD.color.setHex(0x444444); 
                            materials.chunkPinned.color.setHex(0xaaaaaa);
                            materials.chunkGPU.color.setHex(0x000000);
                         }, 4000);
                    }, 2500);
                }
            }
        ];

        function updateUI() {
            const step = steps[currentStep];
            document.getElementById('phase-name').innerText = step.title;
            document.getElementById('explanation-text').innerHTML = step.desc;
            document.getElementById('system-status').innerText = step.status;
            
            step.action();

            // Button logic
            document.getElementById('next-btn').innerText = currentStep === totalSteps - 1 ? "Restart" : "Next Step ->";
        }

        function nextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
            } else {
                currentStep = 0; // Reset
                materials.modelChunk.color.setHex(0x000000); // Reset color
            }
            updateUI();
        }

        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                updateUI();
            }
        }

        // Initial Load
        updateUI();

        // --- ANIMATION LOOP ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            // Rotate packets
            packets.forEach(p => p.rotation.x += 0.1);

            // Idle rotation of servers
            // servers.forEach(s => s.mesh.rotation.y = Math.sin(time * 0.0005) * 0.05);

            updateLabels();
            renderer.render(scene, camera);
        }
        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Basic Orbit Control (Manual implementation to avoid extra dependency for this demo)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', e => { isDragging = true; });
        document.addEventListener('mouseup', e => { isDragging = false; });
        document.addEventListener('mousemove', e => {
            if (isDragging) {
                const deltaMove = {
                    x: e.offsetX - previousMousePosition.x,
                    y: e.offsetY - previousMousePosition.y
                };

                const deltaRotationQuaternion = new THREE.Quaternion()
                    .setFromEuler(new THREE.Euler(
                        toRadians(deltaMove.y * 0.5),
                        toRadians(deltaMove.x * 0.5),
                        0,
                        'XYZ'
                    ));

                // Simply rotating the camera around 0,0,0 for this demo
                // In a real app, OrbitControls is better
                // camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                // For simplicity in this self-contained file, we just move x/z
                
                const radius = Math.sqrt(camera.position.x**2 + camera.position.z**2);
                let angle = Math.atan2(camera.position.z, camera.position.x);
                angle -= deltaMove.x * 0.005;
                
                camera.position.x = radius * Math.cos(angle);
                camera.position.z = radius * Math.sin(angle);
                camera.lookAt(0, 0, 0);
            }
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

    </script>
</body>
</html>